<!DOCTYPE html>
<html lang=en dir="ltr">
<head>
  <meta charset="utf-8"/>
  <title>H2H Sorter</title>
  <link rel="stylesheet" type="text/css" href="style.css">
  <script src="tree.js"></script>
  <script src="sets.js"></script>
</head>

<body>
  <div class="header"> H2H Sorter </div>
  <br>
  <div id="setup">
      <label for="setChoice">Choose a set to sort:</label>
      <select id="setChoice" onchange="checkCustom()">
        <option value="nbaplayers">Top NBA Players</option>
        <option value="nbateams">NBA Teams</option>
        <option value="fruits">Common Fruits</option>
        <option value="custom">Custom Set</option>
      </select>
      <div id="customListDiv" style="display: none;">
        <p> Please enter your custom set below. Each element should be seperated with a comma.</p>
        <textarea name="customList" rows="9" cols="50"></textarea>
      </div>
      <br>
      <br>
      <button type="button" onclick="start()">Start Sorting!</button>
  </div>

  <div id="sorter" style="display: none;">
    <div></div>
    <button id="option0" type="button" onclick="chose(0)">Option 0</button> vs. <button id="option1" type="button" onclick="chose(1)">Option 1</button>
  </div>

  <br>

  <div class="footer"> Â© 2020 MarcerCyoon; All Rights Reserved</div>
</body>

<script>
var set = [];
var tree = [];
var topNode = 0;
// Always start with index 0 and 1 of tree array
var currentNodes = [0, 1];
var setLength = 0;
//var head = 0;
var init = true;

function checkCustom() {
  var opt = document.getElementById("setChoice").value;
  var changeDiv = document.getElementById("customListDiv");
  if (opt == "custom") {
    changeDiv.style.display = "block";
  } else {
    changeDiv.style.display = "none";
  }
}

function start() {
  document.getElementById("setup").style.display = "none";

  var opt = document.getElementById("setChoice").value;

  if (opt == "nbaplayers") {
    set = nbaPlayersSet;
  } else if (opt == "nbateams") {
    set = nbaTeamsSet;
  } else if (opt == "fruits") {
    set = fruitsSet;
  } else {
    // Custom List Support TBA
  }

  setLength = set.length;

  for (var i = 0; i < 2; i += 1) {
    var choice = getRandomInt(0, set.length);
    console.log("Random Value: " + choice);
    const choiceValue = set[choice];
    var node = new Node(choiceValue);
    tree.push(node);
    set.splice(choice, 1);
    var button = document.getElementById("option" + i);
    button.innerHTML = choiceValue;
  }

  document.getElementById("sorter").style.display = "block";
}

function chose(num) {
  if (init) {
    if (num == 1) {
      tree[currentNodes[1]].add_child(tree[currentNodes[0]]);
      topNode = currentNodes[1];
    } else {
      tree[currentNodes[0]].add_child(tree[currentNodes[1]]);
      topNode = currentNodes[0];
    }

    if (tree.length != setLength) {
      var choice = getRandomInt(0, set.length);
      console.log("Random Value: " + choice);
      const choiceValue = set[choice];
      var node = new Node(choiceValue);
      tree.push(node);
      set.splice(choice, 1);

      // Math.abs(num - 1) makes it so if choice was 1, it returns 0, and vice versa
      currentNodes[Math.abs(num - 1)] = tree.length - 1;
      document.getElementById("option" +  Math.abs(num - 1)).innerHTML = choiceValue;
    } else {
      init = false;
      head = topNode;
      findConflict();
    }

  } else { // Initial Tree is finalized; code only reaches here to divide levels
    // Rearrange the tree such that the winning option is now the parent of the losing option
    // Check if head now only has one child
    // If no, choose another random choice and compare again (wait for another choice)
    // If yes, the next head has been decided. Set that as the head node and run findConflict()

    if (num == 1) {
      tree[currentNodes[1]].add_child(tree[currentNodes[0]]);
    } else {
      tree[currentNodes[0]].add_child(tree[currentNodes[1]]);
    }

    console.log(tree[head].children);

    if (tree[head].has_children()) {
      var choice = getRandomInt(0, tree[head].children.length);
      console.log("Random Value: " + choice);
      const choiceNode = tree[head].children[choice];
      tree[head].remove_child(choiceNode);
      var button = document.getElementById("option" + Math.abs(num - 1));
      button.innerHTML = choiceNode.data;
      currentNodes[Math.abs(num - 1)] = tree.indexOf(choiceNode);
    } else {
      tree[head].add_child(tree[currentNodes[num]]);
      head = tree.indexOf(tree[head].children[0]);
      console.log("Changing head to " + tree[head].data);
      findConflict();
    }
  }
}

// Finds a level where there are multiple nodes (a conflict that must be resolved by user).
function findConflict() {
  console.log("Time to Find Conflict!");
  printTree(tree);
  while (tree[head].has_children()) {
    console.log("Current Head is: " + tree[head].data);
    if (tree[head].children.length == 1) {
      console.log("Only has one child! Move on.");
      head = tree.indexOf(tree[head].children[0]);
      continue;
    } else {
      // Find two random options between the children of the node; set them as the buttons
      for (var i = 0; i < 2; i += 1) {
        var choice = getRandomInt(0, tree[head].children.length);
        console.log("Random Value: " + choice);
        const choiceNode = tree[head].children[choice];
        tree[head].remove_child(choiceNode);
        var button = document.getElementById("option" + i);
        button.innerHTML = choiceNode.data;
        currentNodes[i] = tree.indexOf(choiceNode);
      }
      return;
    }
  }

  console.log("Tree Finalized.")
  printTree(tree);
}

function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
   // The maximum is exclusive and the minimum is inclusive
  return Math.floor(Math.random() * (max - min)) + min;
}

</script>
